# Diff

React将传统Diff算法优化，时间复杂度由O(n³)降到了O(n)

## 三个策略

为了将复杂度降到 O(n)，React 基于这三个策略进行了算法优化

1. Web UI 中 DOM 节点跨层级的**移动操作特别少**，可以忽略不计。
2. 拥有相同类的两个组件将会生成**相似**的树形结构，拥有不同类的两个组件将会生成**不同**的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

针对这三个策略，React 分别对 `tree diff`、`component diff` 以及 `element diff` 进行算法优化

### tree diff 分层求异

首先会将新旧两个 DOM 树，进行比较，这个比较指的是分层比较。又由于 DOM 节点跨层级的移动操作很少，忽略不计。React 通过 updataDepth 对 虚拟 DOM 树进行层级控制，只会对同层节点进行比较，也就是图中只会对相同颜色方框内的 DOM 节点进行比较。例如：

当对比发现节点消失时，则该节点及其子节点都会被完全删除，不会进行更深层次的比较，这样只需要对树进行一次遍历，便能完成整颗 DOM 树的比较

![image-20220719151243332](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220719151243332.png)

这里还有一个值得关注的地方：**DOM 节点跨层级移动**

 React 官方并不建议我们进行 DOM 节点跨级操作

### component diff

在组件层面上，也进行了优化

- 如果是同一类型的组件，则按照原策略继续比较 虚拟 DOM tree
- 如果不是，则将这个组件记为 `dirty component` ，从而替换整个组件下的所有子节点

同时对于同一类型的组件，有可能其 `Virtual DOM` 没有任何变化，如果能够确切的知道这点就可以节省大量的 `diff` 运算的时间，因此 `React` 允许用户通过 `shouldComponentUpdate()` 判断该组件是否需要进行 `diff` 算法分析

总的来说，如果两个组件结构相似，但被认定为了不同类型的组件，则不会比较二者的结构，而是直接删除

### element diff

element diff 是专门针对同一层级的所有节点的策略。当节点在同一层级时，diff 提供了 3个节点操作方法：插入，移动，删除

当我们要完成如图所示操作转化时，会有很大的困难，因为在新老节点比较的过程中，发现每个节点都要**删除再重新创建**，但是这只是重新排序了而已，对性能极大的不友好。因此 React 中提出了优化策略：

允许添加**唯一值 key 来区分节点**

![image-20220719152358789](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220719152358789.png)

当同一层级的节点添加了 key 属性后，当位置发生变化时。react diff 进行新旧节点比较，如果发现有相同的 key 就会进行移动操作，而不会删除再创建

首先在 React 中只允许**节点右移**

因此对于上图中的转化，只会进行 A，C 的移动

则只需要对移动的节点进行更新渲染，不移动的则不需要更新渲染

**不能用 index 作为 key 值呢**

`index` 作为 `key` ，如果我们删除了一个节点，那么数组的后一项可能会前移，这个时候移动的节点和删除的节点就是相同的 `key` ，在`react`中，如果 `key` 相同，就会视为**相同的组件**，但这两个组件是不同的，这样就会出现很麻烦的事情，例如：序号和文本不对应等问题

所以一定要保证 `key` 的唯一性

**tree diff 建议**：开发组件时，需要注意保持 DOM 结构稳定

**component diff 建议**：使用 `shouldComponentUpdate()` 来减少不要的更新

**element diff 建议**：减少最后一个节点移动到头部的操作，这样前面的节点都需要移动